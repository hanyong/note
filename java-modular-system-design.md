java 模块化系统设计
===

<div align="right">2014-07-05</div>

## 什么是模块化系统

### 模块化系统的意义

0. 更好的模块化, 拆分 classpath.
0. 更彻底的面向接口编程, 模块间松耦合, 透明替换.
0. 模块间依赖隔离, 避免依赖冲突.

### 模块化系统的定位

理想情况下, 应用所有组件都应该被模块化, 运行在模块化系统之上.

模块化系统分为两个部分:

0. 提供给模块使用的 **模块化层** 基础服务 **API**.
0. 负责安装, 管理, 启动, 停止各个模块的 **模块化框架**. 类似于传统概念上的容器, .

模块化系统具有如下特点:

0. 模块化层是仅次于 jvm 的基础设施.
0. 模块化框架对模块不可见, 模块只能看见模块化层 API. 

一个基于模块化系统构建的 webapp 整体结构示意图如下.

[[java-modular-system-design/webapp-sketch.png]]

>图中实线表示模块间的编译时依赖, 虚线表示运行时依赖.

在 eclipse OSGi 实现中, OSGi 框架本身也是一个模块, 
这样框架本身的实现会受到很多限制, 所以我们不采用这种方式.
模块化框架本身是一个普通的非模块化程序, 但它与模块也是隔离的.
模块化层 API 仍然作为一个特殊的模块存在, 由框架提供.

## 什么是模块

### 导入依赖与内部依赖

简单来说, 一个模块就是一个 maven 项目和它的所有 **内部依赖**.
内部依赖就是普通的 maven 依赖.
一个模块运行时有一个 classloader, 加载模块项目及其所有内部依赖 jar 包.

我们定义一个模块还可以另一种特殊的方式依赖另一个模块, 叫做 **导入依赖**.
运行时导入依赖的 jar 包由当前模块的 classloader 委托另一个模块的 classloader 加载.

导入依赖具有以下特点:

0. 导入依赖没有传递性. A 依赖 B, B 依赖 C, A 不会依赖 C. 
这个特性在 maven 中可用 `<optional>true</optional>` 表示.

    这个特性有两个意义:
    
    0. 这是实现依赖隔离的根本. A 依赖 B, C 时, B, C 的传递依赖互相隔离.
    0. 加载导入类时最多进行一次 classloader 委托. 
模块化系统允许两个模块运行时相互导入依赖 (但启动顺序绝不能相互依赖),
这时可以避免类加载出现死循环.
    
0. 打包模块时不需要打包导入依赖, 对应 `<scope>provided</scope>`.

综上所述, 在 maven 项目, 我们可以通过判断一个依赖同时满足
`<scope>provided</scope>` 和 `<optional>true</optional>`, 
则认为这是一个导入依赖.

导入依赖还可以运行时设置, 创建模块类加载器时, 可动态添加一些导入依赖关系.
应用可能通过某种配置方式支持这种设置.

导入依赖专指模块间的依赖, 也可直接叫做 **模块依赖** .

### 库模块与纯模块

一个普通的 maven 库也是一个合法的模块, 
这个模块只有内部依赖, 没有静态导入依赖, 叫做 **库模块**.
在模块静态关系上, 库模块一定处于模块依赖关系的叶子节点, 
如上文模块化 webapp 示意图中的 `servlet-api`.

与之对应, 包含模块依赖的模块我们叫做 **纯模块** (暂时没想到其他好名字).

一个模块内部依赖一个纯模块时会怎样呢? 间接导入依赖怎么处理? 
为了简化系统模型我们约定纯模块不能作为其他模块的内部依赖, 即只能被导入依赖.
因此我们需要有一个简单有效的方法来识别一个模块是库模块还是纯模块.
我们约定所有普通 maven 库都是库模块, 而纯模块必须设置 "classifier" 为 "mod" 来识别.

**库模块** 可以被内部依赖或导入依赖, 
**纯模块** 只能被导入依赖, 通过 "classifier" 为 "mod" 来识别.

## 导入模块处理

关于导入类还有个有争议的问题: 应该导入类优先还是自身类优先?

* 如果导入类优先, 
    0. 导入模块的所有内部依赖都应该从当前模块裁剪掉, 现有的 maven 依赖解析模型不能满足这种情况 (?).
    0. 导入类处理有一些难题.
如何保证从模块导入的类 (1) 是模块内部依赖的, (2) 同时也是模块实际使用的?
加入 A 导入 B, B 导入 C, C 覆盖了 B 中的类 X, A 从 B 加载类 X 时该如何处理?
如果允许 B 递归委托类加载, 如何避免类加载死循环?

* 如果自身类优先, 希望用导入类覆盖自身类时, 无法单方面强制覆盖. 
A 导入 B 时, A 必须排除 B 的所有内部依赖, 即保证一个 maven 依赖, 在导入依赖与内部依赖中只存在一份.
但类名相同 maven 坐标不同时, 还是无法实现强制覆盖.

如果导入依赖的内部依赖需要在本模块中排除, 
maven 依赖解析似乎变成一个深度优先 + 宽度优先的混合模式?
依赖解析变复杂, 并且当前 maven 依赖解析机制没法支持这种模式.

自身优先实现和逻辑更加简单清晰, 但强制覆盖类的需求不好实现.
是否可以默认自身优先, 但允许调控某些导入依赖优先?

## 模块化最佳实践

为了解决导入依赖难题, 一个办法就是被导入的模块和当前模块不能同时有内部依赖.
这样在一个纯模块的依赖关系中, 只会出现一棵可预测的静态 maven 依赖树.
内部依赖与导入依赖的冲突应该被调解排除, 不会有问题.

再进一步看, 良好的接口实现分离设计下, 模块依赖应该只以接口和服务的方式依赖.
即一个组件总是拆分成 api 和实现两个模块, 其他模块应该只导入依赖 api 模块, 不要导入实现模块,
通过模块化系统的服务层拿到 api 的服务实现.

可使用一个简单的空 maven 项目将一个库模块包装成一个纯模块, 
如将其依赖的 api 设置为导入依赖.

